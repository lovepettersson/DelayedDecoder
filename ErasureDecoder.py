import math
import copy
import numpy as np
from itertools import combinations
# import qecc as q
from itertools import product, chain, permutations, combinations, starmap

from functools import reduce

def eye_p(nq):
    """
    Given a number of qubits, returns the identity Pauli on that many qubits.

    :param int nq: Number of qubits upon which the returned Pauli acts.
    :rtype: :class:`qecc.Pauli`
    :returns: A Pauli operator acting as the identity on each of ``nq`` qubits.
    """
    identity = ""
    for _ in range(nq):
        identity += "I"
    return identity

def powerset(iterable):
    """
    Sub-function, stolen from itertools cookbook.

    powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)
    """
    s = list(iterable)
    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))


def from_generators(gens, coset_rep=None, incl_identity=True):
    """
    Given a list of generators ``gens``, yields an iterator
    onto the group generated by products of elements from
    ``gens``.

    If ``coset_rep`` is specified, returns the coset of the group generated by
    ``gens`` represented by ``coset_rep``.
    """

    if coset_rep is None:
        coset_rep = eye_p(len(gens[0]))

    # print(list(powerset(gens)))
    for prod in powerset(gens):
        if len(prod) > 0:
            yield reduce(lambda P, Q: P * Q, prod, coset_rep)
        elif incl_identity:
            yield coset_rep


def stabilizer_generators(graph, nodes):
    stab_gens = []
    for node in nodes:
        gen = ""
        nbs = [n for n in graph.neighbors(node)]
        for node_idx in nodes:
            if node_idx == node:
                gen += "X"
            elif node_idx in nbs:
                gen += "Z"
            else:
                gen += "I"
        stab_gens.append(gen)
    return stab_gens


class AllPossStrats(object):

    def __init__(self, n_qbts, gstate, in_qbt=0, printing=False):
        # Initialize the decoder
        self.gstate = gstate
        self.n_qbts = n_qbts
        self.in_qubit = in_qbt

    def get_possible_decoding_strats(self):
        num_qubits = len(self.gstate)
        # print("num_qubits", num_qubits)
        # get all possible 2^N stabilizers.
        # TODO: to be improved checking only "smart" stabilizers.
        nodes = [x for x in self.n_qbts]
        gens = stabilizer_generators(self.gstate, nodes) # list(q.from_generators(self.gstate.stab_gens))
        all_stabs = get_full_stabilizer_group(gens, num_qubits)
        poss_stabs_list = []
        for stab_ix1 in range(0, (2 ** num_qubits) - 1):
            for stab_ix2 in range(stab_ix1, 2 ** num_qubits - 1):
                stab1 = all_stabs[stab_ix1]
                stab2 = all_stabs[stab_ix2]
                ## checks which qubits have anticommuting Paulis
                anticomm_qbts = [qbt for qbt in range(num_qubits) if single_qubit_commute(stab1, stab2, qbt)]

                ## checks that there are exactly two qubits with anticommuting Paulis: the input and an output
                if len(anticomm_qbts) == 2 and self.in_qubit in anticomm_qbts:
                    measurement = [stab1[qbt] if stab1[qbt] != 'I' else stab2[qbt] for qbt in range(num_qubits)]
                    other_meas_qubits = [qbt for qbt in range(num_qubits)
                                         if measurement[qbt] != 'I' and qbt not in anticomm_qbts]
                    meas_weight = num_qubits - measurement.count('I')
                    Z_weight = measurement.count('Z') / (meas_weight + 1)
                    poss_stabs_list.append(
                        [anticomm_qbts, other_meas_qubits, [stab1, stab2], measurement, meas_weight])
                    # print(stab1, stab2, anticomm_qbts, other_meas_qubits, measurement, meas_weight)
        # ## order them such that we always prefer mstrategies with smaller weight, and with more Zs in the
        # non-trivial paulis.
        poss_stabs_list.sort(key=lambda x: x[4])
        return poss_stabs_list


class LT_Erasure_decoder(object):
    r"""

    """

    def __init__(self, n_qbts, distance, gstate, in_qbt=0, printing=False):
        # Initialize the decoder
        self.gstate = gstate
        self.n_qbts = n_qbts
        self.distance = distance
        self.in_qbt = in_qbt
        self.n_rows = self.n_qbts + 1
        self.printing = printing
        self.cnt = 0
        self.clashed_strats = []
        self.log_X_idx = -2
        self.log_Z_idx = -1
        self.H_X, self.H_Z = self.H_matrices()
        self.loss_patts = self.get_loss_patterns()
        print("Number of loss patterns: ", len(self.loss_patts))
        self.flag_check, self.strats = self.find_strategies()
        self.strategies_ordered = self.order_strats()
        print("Number of strategies ordered: ", len(self.strategies_ordered))

    def H_matrices(self):
        # progenitor_gens = [self.gstate.stab_gens[idx].op for idx in range(len(self.gstate.stab_gens))]
        nodes = [n for n in range(self.n_qbts + 1)]
        progenitor_gens = stabilizer_generators(self.gstate, nodes)
        log_Z = ""
        for stab in progenitor_gens:
            if stab[self.in_qbt] == "X":
                log_X = stab
            elif stab[self.in_qbt] == "Z" and log_Z == "":
                log_Z = stab
        progenitor_gens.remove(log_X)
        progenitor_gens.remove(log_Z)
        graph_code_gens = []
        for gen in progenitor_gens:
            if gen[self.in_qbt] == "Z":
                graph_code_gens.append(self.multiply_stabs_progenitor_pic(log_Z, gen))
            else:
                graph_code_gens.append(gen)
        H_X, H_Z = self.build_H_matrices([log_X, log_Z], graph_code_gens)
        return H_X, H_Z

    def build_H_matrices(self, logicals, stab_gens):
        H_X = np.zeros((self.n_qbts + 1, self.n_qbts), dtype=int)
        H_Z = np.zeros((self.n_qbts + 1, self.n_qbts), dtype=int)
        for stab_idx, stab in enumerate(stab_gens):
            for qbt_idx in range(1, self.n_qbts + 1):
                if stab[qbt_idx] == "Z":
                    H_Z[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "X":
                    H_X[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "Y":
                    H_X[stab_idx][qbt_idx - 1] = 1
                    H_Z[stab_idx][qbt_idx - 1] = 1
        for stab_idx, stab in enumerate(logicals):
            stab_idx += self.n_qbts - 1
            for qbt_idx in range(1, self.n_qbts + 1):
                if stab[qbt_idx] == "Z":
                    H_Z[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "X":
                    H_X[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "Y":
                    H_X[stab_idx][qbt_idx - 1] = 1
                    H_Z[stab_idx][qbt_idx - 1] = 1
        return H_X, H_Z


    def from_pauli_string_to_Z_field(self, log):
        log_out = np.zeros(2 * self.n_qbts, dtype=int)
        for pauli_idx, pauli in enumerate(log):
            if pauli == "Z":
                log_out[self.n_qbts + pauli_idx] = 1
            elif pauli == "X":
                log_out[pauli_idx] = 1
            elif pauli == "Y":
                log_out[self.n_qbts + pauli_idx] = 1
                log_out[pauli_idx] = 1
        return log_out


    def multiply_stabs_progenitor_pic(self, stab_1, stab_2):
        stab = ""
        for idx in range(self.n_qbts + 1):
            pauli_1 = stab_1[idx]
            pauli_2 = stab_2[idx]
            if (pauli_1 == "Z" and pauli_2 == "Z") or (pauli_1 == "X" and pauli_2 == "X") or (pauli_1 == "Y" and pauli_2 == "Y") or (pauli_1 == "I" and pauli_2 == "I"):
                stab += "I"
            elif (pauli_1 == "Z" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Z"):
                stab += "Z"
            elif (pauli_1 == "X" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "X"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Y"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Z"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "Y") or (pauli_1 == "Y" and pauli_2 == "Z"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Y"):
                stab += "Z"
        return stab



    def multiply_stabs_graph_code_pic(self, stab_1, stab_2):
        stab = ""
        for idx in range(self.n_qbts):
            pauli_1 = stab_1[idx]
            pauli_2 = stab_2[idx]
            if (pauli_1 == "Z" and pauli_2 == "Z") or (pauli_1 == "X" and pauli_2 == "X") or (pauli_1 == "Y" and pauli_2 == "Y") or (pauli_1 == "I" and pauli_2 == "I"):
                stab += "I"
            elif (pauli_1 == "Z" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Z"):
                stab += "Z"
            elif (pauli_1 == "X" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "X"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Y"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Z"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "Y") or (pauli_1 == "Y" and pauli_2 == "Z"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Y"):
                stab += "Z"
        return stab

    def get_loss_patterns(self):
        lost_patterns = []
        idxs = list(combinations(range(self.n_qbts), self.distance))
        for idx_list in idxs:
            # loss_patt = np.zeros(self.n_qbts, dtype=int)
            # for qbt_idx in idx_list:
            #     loss_patt[qbt_idx] = 1
            loss_patt = self.binary_loss_pattern(idx_list)
            lost_patterns.append(loss_patt)
        return lost_patterns

    def binary_loss_pattern(self, idx_list):
        loss_patt = np.zeros(self.n_qbts, dtype=int)
        for qbt_idx in idx_list:
            loss_patt[qbt_idx] = 1
        return loss_patt

    def find_strategies(self):
        strategies = []
        break_flag = False
        covered_loss_patts = []
        for idx_lp, loss_patt in enumerate(self.loss_patts):
            if idx_lp % 500 == 0:
                print("At loss pattern: ", idx_lp)
            if list(loss_patt) not in covered_loss_patts:
                flag, strat = self.run_specific_loss_pattern(loss_patt)
                if flag:
                    strategies.append(strat)
                else:
                    print("Failed: ", loss_patt, strat)
                    break_flag = True
                    break
                idt_support = self.identity_support_of_strat(strat)
                covered_loss_patts.append(list(loss_patt))
                if len(idt_support) > self.distance:
                    combs = list(combinations(idt_support, self.distance))
                    for idx_list in combs:
                        l_patt = self.binary_loss_pattern(idx_list)
                        if list(l_patt) not in covered_loss_patts:
                            covered_loss_patts.append(list(l_patt))

        return break_flag, strategies

    def run_specific_loss_pattern(self, lost_qubits):
        H_X = copy.deepcopy(self.H_X)
        H_Z = copy.deepcopy(self.H_Z)

        num_lost_qbts = np.sum(lost_qubits)
        lostfirst_qbts_order = np.flip(np.argsort(lost_qubits))
        Hwithlogop_ordered_X = H_X[:, lostfirst_qbts_order]
        Hwithlogop_ordered_Z = H_Z[:, lostfirst_qbts_order]
        Hwithlogop_ordered = np.concatenate((Hwithlogop_ordered_X, Hwithlogop_ordered_Z), axis=1)

        # print(Hwithlogop_ordered)
        ref_H, removed_rows = GaussElim_X(Hwithlogop_ordered, self.n_rows, num_lost_qbts)
        # print(removed_rows)
        # print(ref_H)
        ref_H = GaussElim_Z(ref_H, self.n_rows, num_lost_qbts, self.n_qbts, removed_rows, num_lost_qbts)
        # print("ref_H", ref_H)
        # print("lost qbts : ", lost_qubits, lostfirst_qbts_order)
        # print()
        # print(removed_rows)
        # print()
        in_idxs = self.anticommuting_support_idxs(ref_H[-2], ref_H[-1])
        if len(in_idxs) > 1:
            ref_H, flag_f, stabs, l_x, l_z = self.tweak_logs(len(removed_rows), ref_H)
            more_logs = self.tweak_more_logs(len(removed_rows), ref_H)
            print("Number of valid strategies: ", len(more_logs))
        h_x, h_z = np.hsplit(ref_H, 2)
        log_Z_X = np.any(h_x[-1][:num_lost_qbts])
        log_Z_Z = np.any(h_z[-1][:num_lost_qbts])
        log_X_X = np.any(h_x[-2][:num_lost_qbts])
        log_X_Z = np.any(h_z[-2][:num_lost_qbts])
        if not log_Z_X and not log_Z_Z and not log_X_X and not log_X_Z:
            # Build logicals for teleportation
            initial_order = lostfirst_qbts_order
            log_Z = {}
            log_X = {}
            for qbt in range(self.n_qbts):
                log_X[qbt] = ""
                log_Z[qbt] = ""
            for idx in range(self.n_qbts):
                if h_x[-2][idx] == 1 and h_z[-2][idx] == 0:
                    qbt = initial_order[idx]
                    log_X[qbt] = "X"
                elif h_x[-2][idx] == 0 and h_z[-2][idx] == 1:
                    qbt = initial_order[idx]
                    log_X[qbt] = "Z"
                elif h_x[-2][idx] == 1 and h_z[-2][idx] == 1:
                    qbt = initial_order[idx]
                    log_X[qbt] = "Y"
                else:
                    qbt = initial_order[idx]
                    log_X[qbt] = "I"

                if h_x[-1][idx] == 1 and h_z[-1][idx] == 0:
                    qbt = initial_order[idx]
                    log_Z[qbt] = "X"
                elif h_x[-1][idx] == 0 and h_z[-1][idx] == 1:
                    qbt = initial_order[idx]
                    log_Z[qbt] = "Z"
                elif h_x[-1][idx] == 1 and h_z[-1][idx] == 1:
                    qbt = initial_order[idx]
                    log_Z[qbt] = "Y"
                else:
                    qbt = initial_order[idx]
                    log_Z[qbt] = "I"
            strat = self.parse_strategy(log_X, log_Z)
            return True, strat
        else:
            print(h_x[-1], h_x[-2], h_z[-1], h_z[-2])
            return False, []



    def anticommuting_support_idxs(self, log_X, log_Z):
        anticomm_supp = []
        if len(log_X) > self.n_qbts + 1:
            log_X = self.binary_to_str(log_X)
            log_Z = self.binary_to_str(log_Z)
        for qbt in range(self.n_qbts):
            if log_X[qbt] == "X" and log_Z[qbt] == "Z":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "X" and log_Z[qbt] == "Y":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Z" and log_Z[qbt] == "X":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Z" and log_Z[qbt] == "Y":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Y" and log_Z[qbt] == "Z":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Y" and log_Z[qbt] == "X":
                anticomm_supp.append(qbt)
        return anticomm_supp


    def parse_strategy(self, log_X, log_Z):
        strat = []
        pauli_X = "X"
        pauli_Z = "Z"
        for key in log_Z.keys():
            pauli_X += log_X[key]
            pauli_Z += log_Z[key]
        strat.append(pauli_X)
        strat.append(pauli_Z)
        return strat


    def identity_support_of_strat(self, strat):
        pauli_X = strat[0]
        pauli_Z = strat[1]
        identity_supp_list = []
        for qbt_idx in range(1, self.n_qbts + 1):
            if pauli_X[qbt_idx] == pauli_Z[qbt_idx] == "I":
                identity_supp_list.append(qbt_idx-1)
        return identity_supp_list

    def binary_to_str(self, stab):
        pauli = ""
        for idx in range(self.n_qbts):
            if stab[idx] == 1 and stab[idx + self.n_qbts] == 0:
                pauli += "X"
            elif stab[idx] == 0 and stab[idx + self.n_qbts] == 1:
                pauli += "Z"
            elif stab[idx] == 1 and stab[idx + self.n_qbts] == 1:
                pauli += "Y"
            else:
                pauli += "I"
        return pauli

    def order_strats(self):
        poss_stabs_list = []
        for stab_ix in range(len(self.strats)):
            stab1, stab2 = self.strats[stab_ix]
            ## checks which qubits have anticommuting Paulis
            anticomm_qbts = [qbt for qbt in range(self.n_qbts + 1) if single_qubit_commute(stab1, stab2, qbt)]

            ## checks that there are exactly two qubits with anticommuting Paulis: the input and an output
            if len(anticomm_qbts) == 2 and self.in_qbt in anticomm_qbts:
                measurement = [stab1[qbt] if stab1[qbt] != 'I' else stab2[qbt] for qbt in range(self.n_qbts + 1)]
                other_meas_qubits = [qbt for qbt in range(self.n_qbts + 1)
                                     if measurement[qbt] != 'I' and qbt not in anticomm_qbts]
                meas_weight = self.n_qbts - measurement.count('I')
                poss_stabs_list.append(
                    [anticomm_qbts, other_meas_qubits, [stab1, stab2], measurement, meas_weight])
            # else:
            #     self.cnt += 1
            #     self.clashed_strats.append([stab1, stab2])
            else:
                # print("Clash: ", len(anticomm_qbts))
                self.cnt += 1
                self.clashed_strats.append([stab1, stab2])
                adjusted_anticomm_qbts = [anticomm_qbts[0], anticomm_qbts[1]]
                measurement = [stab1[qbt] if stab1[qbt] != 'I' else stab2[qbt] for qbt in range(self.n_qbts + 1)]
                other_meas_qubits = [qbt for qbt in range(self.n_qbts + 1)
                                     if measurement[qbt] != 'I' and qbt not in adjusted_anticomm_qbts]
                meas_weight = self.n_qbts - measurement.count('I')
                poss_stabs_list.append(
                   [adjusted_anticomm_qbts, other_meas_qubits, [stab1, stab2], measurement, meas_weight])
        poss_stabs_list.sort(key=lambda x: x[4])
        return poss_stabs_list




    def tweak_logs(self, n_remove, H):
        stabs = []
        log_X = self.binary_to_str(H[-2])
        log_Z = self.binary_to_str(H[-1])
        anticomm_in = len(self.anticommuting_support_idxs(log_X, log_Z))
        stab_to_idx = []
        for idx in range(n_remove, self.n_rows - 2):
            stabs.append(self.binary_to_str(H[idx]))
            stab_to_idx.append([idx - n_remove])
        stab_generators = copy.deepcopy(stabs)
        # stabs_new = self.parse_stab_gens_for_quecc(stab_generators)
        # stab_group = list(q.from_generators(stabs_new))
        # full_stab_group = [stab.op for stab in stab_group]
        full_stab_group = get_full_stabilizer_group(stab_generators, self.n_qbts)
        for s1 in full_stab_group:
            new_log_X = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_X), s1)
            for s2 in full_stab_group:
                new_log_Z = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_Z), s2)
                ant_supp = self.anticommuting_support_idxs(new_log_X, new_log_Z)
                ant_supp_size = len(ant_supp)
                if ant_supp_size == 1:
                    binary_Z = self.from_pauli_string_to_Z_field(new_log_Z)
                    binary_X = self.from_pauli_string_to_Z_field(new_log_X)
                    H[-2] = binary_X
                    H[-1] = binary_Z
                    return H, True, 1, 1, 1
        print("Anticommuting qbts in: ", anticomm_in)
        return H, False, stabs, log_X, log_Z


    def tweak_more_logs(self, n_remove, H):
        stabs = []
        log_X = self.binary_to_str(H[-2])
        log_Z = self.binary_to_str(H[-1])
        anticomm_in = len(self.anticommuting_support_idxs(log_X, log_Z))
        stab_to_idx = []
        for idx in range(n_remove, self.n_rows - 2):
            stabs.append(self.binary_to_str(H[idx]))
            stab_to_idx.append([idx - n_remove])
        stab_generators = copy.deepcopy(stabs)
        # stabs_new = self.parse_stab_gens_for_quecc(stab_generators)
        # stab_group = list(q.from_generators(stabs_new))
        # full_stab_group = [stab.op for stab in stab_group]
        full_stab_group = get_full_stabilizer_group(stab_generators, self.n_qbts)
        output_strats = []
        for s1 in full_stab_group:
            new_log_X = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_X), s1)
            for s2 in full_stab_group:
                new_log_Z = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_Z), s2)
                ant_supp = self.anticommuting_support_idxs(new_log_X, new_log_Z)
                ant_supp_size = len(ant_supp)
                if ant_supp_size == 1:
                    binary_Z = self.from_pauli_string_to_Z_field(new_log_Z)
                    binary_X = self.from_pauli_string_to_Z_field(new_log_X)
                    H[-2] = binary_X
                    H[-1] = binary_Z
                    output_strats.append([new_log_X, new_log_Z])
        return output_strats



    def gen_stab_group(self, stabs, size):
        prod_combs = list(combinations(range(len(stabs)), size))
        stab_group = []
        for prod in prod_combs:
            stab = stabs[prod[0]]
            for idx in range(1, len(prod)):
                stab = self.multiply_stabs_graph_code_pic(stab, stabs[prod[idx]])
            stab_group.append(stab)
        return stab_group, prod_combs

    def support_overlap(self, log, stab, idxs):
        support_size = 0
        for qbt_idx in idxs:
            if log[qbt_idx] == stab[qbt_idx]:
                support_size += 1
        return support_size


    def parse_stab_gens_for_quecc(self, stabs):
        stab_gens = []
        for stab in stabs:
            stab_dict = {0: stab[0]}
            for node_ix in range(1, len(stab)):
                stab_dict[node_ix] = stab[node_ix]
            this_stab = q.Pauli.from_sparse(stab_dict, nq=len(stab))
            stab_gens.append(this_stab)
        return stab_gens






class LT_Erasure_decoder_All_Strats(object):
    r"""

    """

    def __init__(self, n_qbts, distance, gstate, in_qbt=0, printing=False):
        # Initialize the decoder
        self.gstate = gstate
        self.n_qbts = n_qbts
        self.distance = distance
        self.in_qbt = in_qbt
        self.n_rows = self.n_qbts + 1
        self.printing = printing
        self.cnt = 0
        self.clashed_strats = []
        self.log_X_idx = -2
        self.log_Z_idx = -1
        self.numb_useful_loss_patts = 0
        self.H_X, self.H_Z = self.H_matrices()
        self.loss_patts = self.get_loss_patterns()
        # print("Number of loss patterns: ", len(self.loss_patts))
        self.flag_check, self.strats = self.find_strategies()
        self.strategies_ordered = self.order_strats()
        # print("Number of strategies ordered: ", len(self.strategies_ordered))


    def H_matrices(self):
        # progenitor_gens = [self.gstate.stab_gens[idx].op for idx in range(len(self.gstate.stab_gens))]
        nodes = [n for n in range(self.n_qbts + 1)]
        progenitor_gens = stabilizer_generators(self.gstate, nodes)
        log_Z = ""
        for stab in progenitor_gens:
            if stab[self.in_qbt] == "X":
                log_X = stab
            elif stab[self.in_qbt] == "Z" and log_Z == "":
                log_Z = stab
        progenitor_gens.remove(log_X)
        progenitor_gens.remove(log_Z)
        graph_code_gens = []
        for gen in progenitor_gens:
            if gen[self.in_qbt] == "Z":
                graph_code_gens.append(self.multiply_stabs_progenitor_pic(log_Z, gen))
            else:
                graph_code_gens.append(gen)
        H_X, H_Z = self.build_H_matrices([log_X, log_Z], graph_code_gens)
        return H_X, H_Z

    def build_H_matrices(self, logicals, stab_gens):
        H_X = np.zeros((self.n_qbts + 1, self.n_qbts), dtype=int)
        H_Z = np.zeros((self.n_qbts + 1, self.n_qbts), dtype=int)
        for stab_idx, stab in enumerate(stab_gens):
            for qbt_idx in range(1, self.n_qbts + 1):
                if stab[qbt_idx] == "Z":
                    H_Z[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "X":
                    H_X[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "Y":
                    H_X[stab_idx][qbt_idx - 1] = 1
                    H_Z[stab_idx][qbt_idx - 1] = 1
        for stab_idx, stab in enumerate(logicals):
            stab_idx += self.n_qbts - 1
            for qbt_idx in range(1, self.n_qbts + 1):
                if stab[qbt_idx] == "Z":
                    H_Z[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "X":
                    H_X[stab_idx][qbt_idx - 1] = 1
                elif stab[qbt_idx] == "Y":
                    H_X[stab_idx][qbt_idx - 1] = 1
                    H_Z[stab_idx][qbt_idx - 1] = 1
        return H_X, H_Z


    def from_pauli_string_to_Z_field(self, log):
        log_out = np.zeros(2 * self.n_qbts, dtype=int)
        for pauli_idx, pauli in enumerate(log):
            if pauli == "Z":
                log_out[self.n_qbts + pauli_idx] = 1
            elif pauli == "X":
                log_out[pauli_idx] = 1
            elif pauli == "Y":
                log_out[self.n_qbts + pauli_idx] = 1
                log_out[pauli_idx] = 1
        return log_out


    def multiply_stabs_progenitor_pic(self, stab_1, stab_2):
        stab = ""
        for idx in range(self.n_qbts + 1):
            pauli_1 = stab_1[idx]
            pauli_2 = stab_2[idx]
            if (pauli_1 == "Z" and pauli_2 == "Z") or (pauli_1 == "X" and pauli_2 == "X") or (pauli_1 == "Y" and pauli_2 == "Y") or (pauli_1 == "I" and pauli_2 == "I"):
                stab += "I"
            elif (pauli_1 == "Z" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Z"):
                stab += "Z"
            elif (pauli_1 == "X" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "X"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Y"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Z"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "Y") or (pauli_1 == "Y" and pauli_2 == "Z"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Y"):
                stab += "Z"
        return stab



    def multiply_stabs_graph_code_pic(self, stab_1, stab_2):
        stab = ""
        for idx in range(self.n_qbts):
            pauli_1 = stab_1[idx]
            pauli_2 = stab_2[idx]
            if (pauli_1 == "Z" and pauli_2 == "Z") or (pauli_1 == "X" and pauli_2 == "X") or (pauli_1 == "Y" and pauli_2 == "Y") or (pauli_1 == "I" and pauli_2 == "I"):
                stab += "I"
            elif (pauli_1 == "Z" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Z"):
                stab += "Z"
            elif (pauli_1 == "X" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "X"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Y"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Z"):
                stab += "Y"
            elif (pauli_1 == "Z" and pauli_2 == "Y") or (pauli_1 == "Y" and pauli_2 == "Z"):
                stab += "X"
            elif (pauli_1 == "Y" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Y"):
                stab += "Z"
        return stab

    def get_loss_patterns(self):
        lost_patterns = []
        idxs = list(combinations(range(self.n_qbts), self.distance))
        for idx_list in idxs:
            # loss_patt = np.zeros(self.n_qbts, dtype=int)
            # for qbt_idx in idx_list:
            #     loss_patt[qbt_idx] = 1
            loss_patt = self.binary_loss_pattern(idx_list)
            lost_patterns.append(loss_patt)
        return lost_patterns

    def binary_loss_pattern(self, idx_list):
        loss_patt = np.zeros(self.n_qbts, dtype=int)
        for qbt_idx in idx_list:
            loss_patt[qbt_idx] = 1
        return loss_patt

    def find_strategies(self):
        strategies = []
        break_flag = False
        covered_loss_patts = []
        for idx_lp, loss_patt in enumerate(self.loss_patts):
            if idx_lp % 500 == 0:
                print("At loss pattern: ", idx_lp)
            if list(loss_patt) not in covered_loss_patts:
                flag, strats = self.run_specific_loss_pattern(loss_patt)
                if flag:
                    for strat in strats:
                        strategies.append(strat)
                else:
                    print("Failed: ", loss_patt, strat)
                    break_flag = True
                    break
                # idt_support = self.identity_support_of_strat(strat)
                # covered_loss_patts.append(list(loss_patt))
                # if len(idt_support) > self.distance:
                #     combs = list(combinations(idt_support, self.distance))
                #     for idx_list in combs:
                #         l_patt = self.binary_loss_pattern(idx_list)
                #         if list(l_patt) not in covered_loss_patts:
                #             covered_loss_patts.append(list(l_patt))

        return break_flag, strategies

    def run_specific_loss_pattern(self, lost_qubits):
        H_X = copy.deepcopy(self.H_X)
        H_Z = copy.deepcopy(self.H_Z)

        num_lost_qbts = np.sum(lost_qubits)
        lostfirst_qbts_order = np.flip(np.argsort(lost_qubits))
        Hwithlogop_ordered_X = H_X[:, lostfirst_qbts_order]
        Hwithlogop_ordered_Z = H_Z[:, lostfirst_qbts_order]
        Hwithlogop_ordered = np.concatenate((Hwithlogop_ordered_X, Hwithlogop_ordered_Z), axis=1)

        # print(Hwithlogop_ordered)
        ref_H, removed_rows = GaussElim_X(Hwithlogop_ordered, self.n_rows, num_lost_qbts)
        # print(removed_rows)
        # print(ref_H)
        ref_H = GaussElim_Z(ref_H, self.n_rows, num_lost_qbts, self.n_qbts, removed_rows, num_lost_qbts)
        in_idxs = self.anticommuting_support_idxs(ref_H[-2], ref_H[-1])
        ref_H_s, flag_f, stabs, l_x, l_z = self.tweak_logs(len(removed_rows), ref_H)
        # print("Number of valid strategies: ", len(ref_H_s))
        out_strategies = []
        for ref_H in ref_H_s:
            h_x, h_z = np.hsplit(ref_H, 2)
            log_Z_X = np.any(h_x[-1][:num_lost_qbts])
            log_Z_Z = np.any(h_z[-1][:num_lost_qbts])
            log_X_X = np.any(h_x[-2][:num_lost_qbts])
            log_X_Z = np.any(h_z[-2][:num_lost_qbts])
            if not log_Z_X and not log_Z_Z and not log_X_X and not log_X_Z:
                # Build logicals for teleportation
                initial_order = lostfirst_qbts_order
                log_Z = {}
                log_X = {}
                for qbt in range(self.n_qbts):
                    log_X[qbt] = ""
                    log_Z[qbt] = ""
                for idx in range(self.n_qbts):
                    if h_x[-2][idx] == 1 and h_z[-2][idx] == 0:
                        qbt = initial_order[idx]
                        log_X[qbt] = "X"
                    elif h_x[-2][idx] == 0 and h_z[-2][idx] == 1:
                        qbt = initial_order[idx]
                        log_X[qbt] = "Z"
                    elif h_x[-2][idx] == 1 and h_z[-2][idx] == 1:
                        qbt = initial_order[idx]
                        log_X[qbt] = "Y"
                    else:
                        qbt = initial_order[idx]
                        log_X[qbt] = "I"

                    if h_x[-1][idx] == 1 and h_z[-1][idx] == 0:
                        qbt = initial_order[idx]
                        log_Z[qbt] = "X"
                    elif h_x[-1][idx] == 0 and h_z[-1][idx] == 1:
                        qbt = initial_order[idx]
                        log_Z[qbt] = "Z"
                    elif h_x[-1][idx] == 1 and h_z[-1][idx] == 1:
                        qbt = initial_order[idx]
                        log_Z[qbt] = "Y"
                    else:
                        qbt = initial_order[idx]
                        log_Z[qbt] = "I"
                strat = self.parse_strategy(log_X, log_Z)
                out_strategies.append(strat)

        if len(out_strategies) > 0:
            return True, out_strategies
        else:
            return False, []

    def anticommuting_support_idxs(self, log_X, log_Z):
        anticomm_supp = []
        if len(log_X) > self.n_qbts + 1:
            log_X = self.binary_to_str(log_X)
            log_Z = self.binary_to_str(log_Z)
        for qbt in range(self.n_qbts):
            if log_X[qbt] == "X" and log_Z[qbt] == "Z":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "X" and log_Z[qbt] == "Y":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Z" and log_Z[qbt] == "X":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Z" and log_Z[qbt] == "Y":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Y" and log_Z[qbt] == "Z":
                anticomm_supp.append(qbt)
            elif log_X[qbt] == "Y" and log_Z[qbt] == "X":
                anticomm_supp.append(qbt)
        return anticomm_supp


    def parse_strategy(self, log_X, log_Z):
        strat = []
        pauli_X = "X"
        pauli_Z = "Z"
        for key in log_Z.keys():
            pauli_X += log_X[key]
            pauli_Z += log_Z[key]
        strat.append(pauli_X)
        strat.append(pauli_Z)
        return strat


    def identity_support_of_strat(self, strat):
        pauli_X = strat[0]
        pauli_Z = strat[1]
        identity_supp_list = []
        for qbt_idx in range(1, self.n_qbts + 1):
            if pauli_X[qbt_idx] == pauli_Z[qbt_idx] == "I":
                identity_supp_list.append(qbt_idx-1)
        return identity_supp_list

    def binary_to_str(self, stab):
        pauli = ""
        for idx in range(self.n_qbts):
            if stab[idx] == 1 and stab[idx + self.n_qbts] == 0:
                pauli += "X"
            elif stab[idx] == 0 and stab[idx + self.n_qbts] == 1:
                pauli += "Z"
            elif stab[idx] == 1 and stab[idx + self.n_qbts] == 1:
                pauli += "Y"
            else:
                pauli += "I"
        return pauli

    def order_strats(self):
        poss_stabs_list = []
        for stab_ix in range(len(self.strats)):
            stab1, stab2 = self.strats[stab_ix]
            ## checks which qubits have anticommuting Paulis
            anticomm_qbts = [qbt for qbt in range(self.n_qbts + 1) if single_qubit_commute(stab1, stab2, qbt)]

            ## checks that there are exactly two qubits with anticommuting Paulis: the input and an output
            if len(anticomm_qbts) == 2 and self.in_qbt in anticomm_qbts:
                measurement = [stab1[qbt] if stab1[qbt] != 'I' else stab2[qbt] for qbt in range(self.n_qbts + 1)]
                other_meas_qubits = [qbt for qbt in range(self.n_qbts + 1)
                                     if measurement[qbt] != 'I' and qbt not in anticomm_qbts]
                meas_weight = self.n_qbts - measurement.count('I')
                poss_stabs_list.append(
                    [anticomm_qbts, other_meas_qubits, [stab1, stab2], measurement, meas_weight])
            # else:
            #     self.cnt += 1
            #     self.clashed_strats.append([stab1, stab2])
            else:
                # print("Clash: ", len(anticomm_qbts))
                self.cnt += 1
                self.clashed_strats.append([stab1, stab2])
                adjusted_anticomm_qbts = [anticomm_qbts[0], anticomm_qbts[1]]
                measurement = [stab1[qbt] if stab1[qbt] != 'I' else stab2[qbt] for qbt in range(self.n_qbts + 1)]
                other_meas_qubits = [qbt for qbt in range(self.n_qbts + 1)
                                     if measurement[qbt] != 'I' and qbt not in adjusted_anticomm_qbts]
                meas_weight = self.n_qbts - measurement.count('I')
                poss_stabs_list.append(
                   [adjusted_anticomm_qbts, other_meas_qubits, [stab1, stab2], measurement, meas_weight])
        poss_stabs_list.sort(key=lambda x: x[4])
        return poss_stabs_list



    '''
    def tweak_logs(self, n_remove, H):
        stabs = []
        log_X = self.binary_to_str(H[-2])
        log_Z = self.binary_to_str(H[-1])
        anticomm_in = len(self.anticommuting_support_idxs(log_X, log_Z))
        stab_to_idx = []
        for idx in range(n_remove, self.n_rows - 2):
            stabs.append(self.binary_to_str(H[idx]))
            stab_to_idx.append([idx - n_remove])
        stab_generators = copy.deepcopy(stabs)
        # stabs_new = self.parse_stab_gens_for_quecc(stab_generators)
        # stab_group = list(q.from_generators(stabs_new))
        # full_stab_group = [stab.op for stab in stab_group]
        full_stab_group = get_full_stabilizer_group(stab_generators, self.n_qbts)
        for s1 in full_stab_group:
            new_log_X = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_X), s1)
            for s2 in full_stab_group:
                new_log_Z = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_Z), s2)
                ant_supp = self.anticommuting_support_idxs(new_log_X, new_log_Z)
                ant_supp_size = len(ant_supp)
                if ant_supp_size == 1:
                    binary_Z = self.from_pauli_string_to_Z_field(new_log_Z)
                    binary_X = self.from_pauli_string_to_Z_field(new_log_X)
                    H[-2] = binary_X
                    H[-1] = binary_Z
                    return H, True, 1, 1, 1
        print("Anticommuting qbts in: ", anticomm_in)
        return H, False, stabs, log_X, log_Z
    '''


    def tweak_logs(self, n_remove, H):
        stabs = []
        log_X = self.binary_to_str(H[-2])
        log_Z = self.binary_to_str(H[-1])
        anticomm_in = len(self.anticommuting_support_idxs(log_X, log_Z))
        stab_to_idx = []
        for idx in range(n_remove, self.n_rows - 2):
            stabs.append(self.binary_to_str(H[idx]))
            stab_to_idx.append([idx - n_remove])
        stab_generators = copy.deepcopy(stabs)
        # stabs_new = self.parse_stab_gens_for_quecc(stab_generators)
        # stab_group = list(q.from_generators(stabs_new))
        # full_stab_group = [stab.op for stab in stab_group]
        full_stab_group = get_full_stabilizer_group(stab_generators, self.n_qbts)
        output_strats = []
        for s1 in full_stab_group:
            new_log_X = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_X), s1)
            for s2 in full_stab_group:
                new_log_Z = self.multiply_stabs_graph_code_pic(copy.deepcopy(log_Z), s2)
                ant_supp = self.anticommuting_support_idxs(new_log_X, new_log_Z)
                ant_supp_size = len(ant_supp)
                if ant_supp_size == 1:
                    new_H = copy.deepcopy(H)
                    binary_Z = self.from_pauli_string_to_Z_field(new_log_Z)
                    binary_X = self.from_pauli_string_to_Z_field(new_log_X)
                    new_H[-2] = binary_X
                    new_H[-1] = binary_Z
                    output_strats.append(new_H)
        return output_strats, True, 1, 1, 1



    def gen_stab_group(self, stabs, size):
        prod_combs = list(combinations(range(len(stabs)), size))
        stab_group = []
        for prod in prod_combs:
            stab = stabs[prod[0]]
            for idx in range(1, len(prod)):
                stab = self.multiply_stabs_graph_code_pic(stab, stabs[prod[idx]])
            stab_group.append(stab)
        return stab_group, prod_combs

    def support_overlap(self, log, stab, idxs):
        support_size = 0
        for qbt_idx in idxs:
            if log[qbt_idx] == stab[qbt_idx]:
                support_size += 1
        return support_size


    def parse_stab_gens_for_quecc(self, stabs):
        stab_gens = []
        for stab in stabs:
            stab_dict = {0: stab[0]}
            for node_ix in range(1, len(stab)):
                stab_dict[node_ix] = stab[node_ix]
            this_stab = q.Pauli.from_sparse(stab_dict, nq=len(stab))
            stab_gens.append(this_stab)
        return stab_gens


def binom_coeff(n, k):
    return math.factorial(n) / (math.factorial(k) * math.factorial(n - k))


def GaussElim_X(H, n_rows, num_eliminated_col, start=0):
    removed_rows = []
    lead = 0
    REF_H = H.copy()
    for ix_r in range(start, n_rows-2):
        if lead >= num_eliminated_col:
            return REF_H, removed_rows
        i = ix_r
        while REF_H[i][lead] == 0:
            i += 1
            if i == n_rows-2:
                i = ix_r
                lead += 1
                if lead >= num_eliminated_col:
                    return REF_H, removed_rows
        if i != ix_r:
            switchrows(REF_H, ix_r, i)
        removed_rows.append(ix_r)
        # print(i, lead, ix_r, n_rows)
        for j in range(ix_r + 1, n_rows):
            if REF_H[j][lead] != 0:
                subtractrows(REF_H, ix_r, j)
        lead += 1
    return REF_H, removed_rows



def GaussElim_Z(H, n_rows, num_eliminated_col, n_col, removed_rows, n_rem):
    lead = n_col
    REF_H = H.copy()
    for ix_r in range(0, n_rows-2):
        if ix_r in removed_rows:
            continue
        if lead >= n_col + num_eliminated_col:
            return REF_H
        i = ix_r
        while REF_H[i][lead] == 0:
            i += 1
            if i == n_rows-2:
                i = ix_r
                lead += 1
                if lead >= n_col + num_eliminated_col:
                    return REF_H
        if i != ix_r:
            switchrows(REF_H, ix_r, i)
        removed_rows.append(ix_r)
        # print(i, lead, ix_r, n_rows)
        for j in range(ix_r + 1, n_rows):
            if REF_H[j][lead] != 0:
                subtractrows(REF_H, ix_r, j)
        lead += 1
    return REF_H






def remove_specific_support(H, n_rows, log_idx, start=0, qbt_idxs=[], printing=False):
    REF_H = H.copy()
    for ix_l in qbt_idxs:
        for ix_r in range(start, n_rows - 2):
            if printing:
                print("ix_r, ix_l, REF_H ", ix_r, ix_l,REF_H[ix_r][ix_l])
            if REF_H[ix_r][ix_l] == 1 and REF_H[log_idx][ix_l] == 1:
                subtractrows(REF_H, ix_r, log_idx)

    return REF_H


def remove_specific_support_Y(H, n_rows, log_idx, n_qbts, start=0, qbt_idxs=[], printing=False):
    REF_H = H.copy()
    for ix_l in qbt_idxs:
        for ix_r in range(start, n_rows - 2):
            if printing:
                print("ix_r, ix_l, REF_H ", ix_r, ix_l,REF_H[ix_r][ix_l])
            if REF_H[ix_r][ix_l] == 1 and REF_H[log_idx][ix_l] == 1 and REF_H[ix_r][ix_l + n_qbts] == 1 and REF_H[log_idx][ix_l + n_qbts] == 1:
                subtractrows(REF_H, ix_r, log_idx)

    return REF_H


def subtractrows(H, ix_r, j):
    H[j] = (H[j] - H[ix_r]) % 2


def switchrows(H, ix_r, i):
    H[[ix_r, i]] = H[[i, ix_r]]


def single_qubit_commute(pauli1, pauli2, qbt):
    """
    Returns 0 if the operators on the qbt-th qubit of the two operators in the Pauli group commute,
    and 1 if they anticommute.
    """
    if pauli1[qbt] == 'I' or pauli2[qbt] == 'I' or pauli1[qbt] == pauli2[qbt]:
        return 0
    else:
        return 1


def interchange_nodes(node1, edges, node2=0):
    new_edges = []
    for edge in edges:
        n1, n2 = edge
        if (n1 == node2 and n2 == node1) or (n2 == node2 and n1 == node1):
            new_edges.append(edge)
        elif n1 == node1:
            new_edge = [node2, n2]
            new_edges.append(new_edge)
        elif n1 == node2:
            new_edge = [node1, n2]
            new_edges.append(new_edge)
        elif n2 == node1:
            new_edge = [node2, n1]
            new_edges.append(new_edge)
        elif n2 == node2:
            new_edge = [node1, n1]
            new_edges.append(new_edge)
        else:
            new_edges.append(edge)
    return new_edges


def multiply_stabs_graph_code_pic(stab_1, stab_2, n_qbts=13):
    stab = ""
    for idx in range(n_qbts):
        pauli_1 = stab_1[idx]
        pauli_2 = stab_2[idx]
        if (pauli_1 == "Z" and pauli_2 == "Z") or (pauli_1 == "X" and pauli_2 == "X") or (pauli_1 == "Y" and pauli_2 == "Y") or (pauli_1 == "I" and pauli_2 == "I"):
            stab += "I"
        elif (pauli_1 == "Z" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Z"):
            stab += "Z"
        elif (pauli_1 == "X" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "X"):
            stab += "X"
        elif (pauli_1 == "Y" and pauli_2 == "I") or (pauli_1 == "I" and pauli_2 == "Y"):
            stab += "Y"
        elif (pauli_1 == "Z" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Z"):
            stab += "Y"
        elif (pauli_1 == "Z" and pauli_2 == "Y") or (pauli_1 == "Y" and pauli_2 == "Z"):
            stab += "X"
        elif (pauli_1 == "Y" and pauli_2 == "X") or (pauli_1 == "X" and pauli_2 == "Y"):
            stab += "Z"
    return stab

def get_full_stabilizer_group(gens, n_qbts=13):
    full_group = []
    sets_to_multiply = powerset(gens)
    for prod in sets_to_multiply:
        if len(prod) > 1:
            stab_1 = prod[0]
            for idx in range(1, len(prod)):
                stab_1 = multiply_stabs_graph_code_pic(stab_1, prod[idx], n_qbts=n_qbts)
            full_group.append(stab_1)
        elif len(prod) == 1:
            full_group.append(prod[0])
    return full_group

if __name__ == '__main__':
    import numpy as np
    from CodeFunctions.graphs import *
    # TODO: Make faster by eliminating loss_patts!


    from itertools import product, chain, permutations, combinations, starmap

    from functools import reduce

    def eye_p(nq):
        """
        Given a number of qubits, returns the identity Pauli on that many qubits.

        :param int nq: Number of qubits upon which the returned Pauli acts.
        :rtype: :class:`qecc.Pauli`
        :returns: A Pauli operator acting as the identity on each of ``nq`` qubits.
        """
        identity = ""
        for _ in range(nq):
            identity += "I"
        return identity

    def powerset(iterable):
        """
        Sub-function, stolen from itertools cookbook.

        powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)
        """
        s = list(iterable)
        return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))


    def from_generators(gens, coset_rep=None, incl_identity=True):
        """
        Given a list of generators ``gens``, yields an iterator
        onto the group generated by products of elements from
        ``gens``.

        If ``coset_rep`` is specified, returns the coset of the group generated by
        ``gens`` represented by ``coset_rep``.
        """

        if coset_rep is None:
            coset_rep = eye_p(len(gens[0]))

        print(list(powerset(gens)))
        for prod in powerset(gens):
            if len(prod) > 0:
                yield reduce(lambda P, Q: P * Q, prod, coset_rep)
            elif incl_identity:
                yield coset_rep


    # stabs_new = ["i^0 IIIZIXZZZZ", "i^0 IIIYZIXXIY", "i^0 IIIZZZIIXZ"]
    # stabs_new = ["IIIZIXZZZZ", "IIIYZIXXIY", "IIIZZZIIXZ"]
    # get_full_stabilizer_group(stabs_new)
    # stab_group = list(from_generators(stabs_new))

    loss_patterns = list(combinations(range(23), 6))
    print(len(loss_patterns))


    last_node = 10
    n_qbts = last_node
    graph_nodes = list(range(n_qbts + 1))
    in_qubit = 0
    patterns = list(permutations(range(1, n_qbts + 1), n_qbts))
    graph_nodes = list(range(n_qbts + 1))
    graph_edges = [(10, 1), (10, 2), (10, 5), (10, 4), (10, 3), (0, 10), (10, 6), (10, 8),
                                  (1, 2), (1, 5), (1, 9), (1, 8), (2, 7), (2, 5), (3, 4), (3, 5),
                                  (3, 9), (3, 6), (4, 5), (4, 7), (4, 0), (6, 8), (6, 9), (6, 7),
                                  (7, 0), (8, 9), (9, 0)]
    gstate = graph_from_nodes_and_edges(graph_nodes,
                                        graph_edges)
    # erasure_decoder = LT_Erasure_decoder(n_qbts, 3, gstate, in_qbt=in_qubit)
    erasure_decoder = LT_Erasure_decoder_All_Strats(n_qbts, 3, gstate, in_qbt=in_qubit)